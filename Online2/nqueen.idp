vocabulary V {
    type Index := {1..7}
    type solution := {s1,s2}
    //type solution := {s1}
    queen : solution * Index * Index -> Bool
    distance: solution * solution -> Int
    n: () -> Int
    k: () -> Int

}

structure S:V {
    //queen := {(s1, 1, 4), (s1, 2, 1), (s1, 3, 5), (s1, 4, 2), (s1, 5, 6), (s1, 6, 3), (s1, 7, 7)}.
    n := 7.
}

theory T:V {

    queen(s1, 1, 4) & queen(s1, 2, 1) & queen(s1, 3, 5) & queen(s1, 4, 2) & queen(s1, 5, 6) & queen(s1, 6, 3) & queen(s1, 7, 7).
    
    !x,y,u,v in Index: !s in solution: queen(s,x,y) & queen(s,u,v) & x~=u & y~=v  => (v ~= -u + x + y).
    !x,y,u,v in Index: !s in solution: queen(s,x,y) & queen(s,u,v) & x~=u & y~=v => (v ~= u - x + y).
    !x,y,u,v in Index: !s in solution: queen(s,x,y) & queen(s,u,v) & y~=v => (x ~= u).
    !x,y,u,v in Index: !s in solution: queen(s,x,y) & queen(s,u,v) & x~=u => (y ~= v).
    
    !s in solution: #{x,y in Index : queen(s,x,y)} = n().
    
    !sx,sy in solution: distance(sx,sy) = #{x,y in Index: queen(sx,x,y) ~= queen(sy,x,y)}/2.
    k() < sum{{distance(sx,sy) | sx,sy in solution: sx ~= sy }}/2.

    //k() = 4.
}

procedure main() {
    pretty_print(model_expand(T, S,max=100))
}
